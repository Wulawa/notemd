# 优化代码质量

## 代码技巧
#### 1. 简洁语法
```javascript
// 箭头函数
const foo = () => console.log('hello world')

// 数组去重
const formatArray = arr => [...new Set(arr)]

// 数组合并
const newArr = [...arr1, ...arr2, 'value']

// 对象浅拷贝
const newObj = {...obj}

// 解构赋值
const person = {name: 'bao', age: 18}
const { name, age } = person

// 显式转换number
+new Date()
+'2'

// 按位取反 配合indexof，findeIndex判断是否存在
～-1 
// => 0
```

#### 2. 优化逻辑判断语句

```javascript
// bad way
const foo = v => {
  if (v === 'name') {
    return 'bao'
  } else if (v === 'age') {
    return '18'
  } else if (v === 'height') {
    return '180'
  }
}
updateMajorHandle(type, e) {
  // debugger
  // console.log(1);
  if (!this.initOk) {
    return;
  }
  if (!this.currentActive.isPay) {
    this.$nextTick(() => {
      !type
        ? ''
        : type === 'iframe'
          ? (this.ruleForm.iframe = '')
          : type === 'toInput'
            ? (this.ruleForm.advertLink = '')
            : type === 'isPure'
              ? (this.ruleForm.iconSwitch[type] = 0)
              : type === 'gobackHome'
                ? (this.ruleForm.iconSwitch[type] = 1)
                : (this.ruleForm[type] = '');
    });
    this.updateMajor(this);
  }
},

// 数组配置法
if (to.path === '/create' || to.path === '/mine' || to.path === '/aaaa') {
  // ...
}
// good way
const cfg = {
  name: 'bao',
  age: '18',
  height: '180'
}
const foo = v => cfg[v]

updateMajorHandle(type, e) {
  if (!this.initOk && this.currentActive.isPay) return;
  switch(type){ 
    case 'iframe':
      this.ruleForm.iframe = ''
      break;
    case 'toInput':
      this.ruleForm.advertLink = ''
      break;
    case 'isPure':
      this.ruleForm.iconSwitch[type] = 0
      break;     
    case 'gobackHome':
      this.ruleForm.iconSwitch[type] = 1
      break;  
    default:
      this.ruleForm[type] = ''
  }
  this.updateMajor(this);
},

// 配置数组形式
const rightValue = ['/create', '/mine', '/aaaa'];

if (rightValue.includes[to.path]) {
  // ...
}

```
#### 3. 善用 && 、 || 和 三元运算
```javascript

// bad way
if (name === 'bao') {
  someFunc()
}

// good way
name === 'bao' && someFunc()

// bad way
someFunc && someFunc();
// good way
someFunc?.()
// bad way
if (name === 'bao') {
  someFunc()
} else {
  elseFunc()
}

// good way
name === 'bao' ? someFunc() : elseFunc();

// bad way
if (val) {
  document.querySelector(
    '.classifyPage .classifyLiveList'
  ).style.overflow =
    'hidden';
} else {
  document.querySelector(
    '.classifyPage .classifyLiveList'
  ).style.overflow =
    '';
}
// good way
const overflow = val ? 'hidden' : '';
document.querySelector('.classifyPage .classifyLiveList').style.overflow = overflow

// bad way
if (isMember) {
  let res = await actions.getMemberInfo(params)
} else {
  let res = await actions.getCommonUserInfo(params)
}
// good way
const actionName = isMember ? 'getMemberInfo' : 'getCommonUserInfo'
let res = await actions[actionName](params)
多层判断按优先级排列
return (
  this.show && // 显示工具条
  !this.info.iconSwitch.isPure &&   // 非纯净模式
  this.info.iconSwitch.review && // 打开评论功能
  !this.showComment && // 未打开评论框
  this.openDanmaku && // 显示弹幕
);
```

#### 4. 减少for循环的使用

用好 filter，map，和其它 ES6 新增的高阶遍历函数
```javascript
// 取差集
export const difference = (a, b) =>
	a.concat(b).filter(v => a.includes(v) && !b.includes(v));

// 取制定长度的 指定大小的随机数
const genNumArr = (length, limit) =>
  Array.from({ length }, i => Math.floor(Math.random() * limit));

// bad way
if (
  !(
    fileType.indexOf('jpeg') > -1 ||
    fileType.indexOf('jpg') > -1 ||
    fileType.indexOf('png') > -1 ||
    fileType.indexOf('gif') > -1
  )
) {
  this.$vux.toast.text(
    '只能上传.jpg  .png  .jpeg  .gif类型的文件'
  );
  e.target.value = '';
  return;
}

// good way
const types = ['jpeg', 'jpg', 'png', 'gif'];
const right = types.some(v => fileType.includes(v));

if(!right) this.$vux.toast.text('只能上传.jpg  .png  .jpeg  .gif类型的文件');

```
###### reduce
将多层数组转换成一层数组
```javascript
const nestedArr = [1, 2, [3, 4, [5, 6]]];

const flatten = arr =>
  arr.reduce(
    (pre, curr) => pre.concat(Array.isArray(curr) ? flatten(curr) : curr),
    []
  );
```
根据指定key进行去重
```javascript
uniq4Id(arr) {
    if (!(arr instanceof Array)) return arr;
    const uniqObj = arr.reduce((pre, curr) => {
      pre[curr.id] = curr;
      return pre;
    }, {});
    return Object.values(uniqObj);
  }  
```
两个数据索引对应值做处理，返回长度为较小长度的处理后的数组
##### 用递归代替循环
```javascript
const num1 = [3, 4, 5, 6, 7];
const num2 = [43, 23, 5, 67, 87, 3, 6];
const zipWith = f => xs => ys => {
  if (xs.length === 0 || ys.length === 0) return [];
  const [xHead, ...xTail] = xs;
  const [yHead, ...yTail] = ys;
  return [f(xHead)(yHead), ...zipWith(f)(xTail)(yTail)];
};

const add = x => y => x + y;

zipWith(add)(num1)(num2);
```


#### 5. transducer
```javascript
const filter = (fn, arr) => arr.reduce((p,c) => (fn(c) && p.push(c), p),[]);
const map = (fn,arr) => arr.reduce((p,c) => (p.push(fn(c), p)),[]);
```
抽离公共层

```javascript
const filter = f => reducer => (acc, value) => {
  if (f(value)) return reducer(acc, value);
  return acc;
};

const map = f => reducer => (acc, value) => reducer(acc, f(value));
```

```javascript
const pushReducer = (arr, val) => (arr.push(val), arr);

bigNums.reduce(map(isEven)(filter(double)(pushReducer)), []);
```

```javascript
const comp = (...fns) => (...args) => fns.reduce((fx, fy) => fy(fx), ...args);

bigNum.reduce(comp(
  map(isEven),
  filter(double),
)(pushReducer), []);

```

## 工具函数
#### 1. curring

> 一个curring的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数中被真正的需要求值的时候，之前传入的所有参数被一次性用于求值。

```javascript
// 期望
const fn = throttle(() => {}, 1000);

fn();

```
典型应用 节流 防抖

```javascript
const throttle = (fn, delay) => {
  let last = 0;
  let timer = null;
  return (...args) => {
    let now = +new Date();
    if(last && now - last < delay) {
      clearTimeout(timer);
      timer = setTimeout(() => {
        last = now;
        fn(...args);
      }, delay)
    } else {
      last = now;
      fn(...args);
    }
  }
}

```
经典debounce
```javascript
function debounce(method, context){
  clearTimer(method.timer)
  method.timer = setTimeout(function() {
    method.call(context);
  }, 100)
}
```

#### 2. 惰性加载函数
> 在Web开发中，因为一些浏览器中的差异，一些嗅探工作总是不可避免的。

```javascript
// 常用的事件兼容
const addEvent = function(el, type, handler) {
 if (window.addEventListener) {
   return el.addEventListener(type, handler, false)
 }
 // for IE
 if (window.attachEvent) {
   return el.attachEvent(`on${type}`, handler)
 }
}
```
缺点： 每次执行都要执行一遍if语句

```javascript
// 结合柯里化函数
const addEventOptimization = () => {
  if (window.addEventListener) {
   return () =>  el.addEventListener(type, handler, false)
  }
 // for IE
 if (window.attachEvent) {
   return () => el.attachEvent(`on${type}`, handler)
 }
}
const addEvent = addEventOptimization();
```
缺点 ： 即便不使用依然需要执行嗅探函数

```javascript
// 惰性加载函数
let addEventLazy = (el, type, handler) => {
 if (window.addEventListener) {
   // 一旦进入分支，便在函数内部修改函数的实现
   addEventLazy = (el, type, handler) => {
     el.addEventListener(type, handler, false)
   }
 } else if (window.attachEvent) {
   addEventLazy = (el, type, handler) => {
     el.attachEvent(`on${type}`, handler)
   }
 }
 addEventLazy(el, type, handler)
}

addEventLazy(document.getElementById('eventLazy'), 'click', () => {
 console.log('lazy ')
})
```
#### 3. 惰性求值 
> 它的目的是要最小化计算机要做的工作。 惰性求值中的参数直到需要时才会进行计算。

[fork:]('http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/')

```javascript
// lodash
function priceLt(x) {
   return function(item) { return item.price < x; };
}
var gems = [
   { name: 'Sunstone', price: 4 },
   { name: 'Amethyst', price: 15 },
   { name: 'Prehnite', price: 20},
   { name: 'Sugilite', price: 7  },
   { name: 'Diopside', price: 3 },
   { name: 'Feldspar', price: 13 },
   { name: 'Dioptase', price: 2 },
   { name: 'Sapphire', price: 20 }
];
 
var chosen = _(gems).filter(priceLt(10)).take(3).value();
```
## 框架应用

## 架构工具

## 打包构建

## 网络请求